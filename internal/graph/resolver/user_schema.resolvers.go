package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.67

import (
	"context"
	"fmt"

	"bitbucket.org/edts/go-task-management/internal/graph/_generated"
	_model "bitbucket.org/edts/go-task-management/internal/model"
	_genModel "bitbucket.org/edts/go-task-management/internal/model/_generated"
)

// RegisterUser is the resolver for the registerUser field.
func (r *mutationResolver) RegisterUser(ctx context.Context, input _genModel.CreateUserInput) (*_model.User, error) {
	// Call the usecase
	createdUser, err := r.Usecase.AuthUsecase.RegisterUser(ctx, input)
	if err != nil {
		return nil, err
	}
	return createdUser, nil
}

// LoginUser is the resolver for the loginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, input _genModel.LoginUserInput) (*_genModel.AuthResponse, error) {
	loginUser, err := r.Usecase.AuthUsecase.LoginUser(ctx, input)
	if err != nil {
		return nil, err
	}
	return loginUser, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input _genModel.RefreshTokenInput) (*_genModel.AuthResponse, error) {
	token, err := r.Usecase.AuthUsecase.RefreshToken(ctx, input)
	if err != nil {
		return nil, err
	}
	return token, nil
}

// LogoutUser is the resolver for the logoutUser field.
func (r *mutationResolver) LogoutUser(ctx context.Context, input _genModel.RefreshTokenInput) (bool, error) {
	isLogout, err := r.Usecase.AuthUsecase.LogoutUser(ctx, input)
	if err != nil {
		return false, err
	}
	return isLogout, nil
}

// CreatedBy is the resolver for the createdBy field.
func (r *userResolver) CreatedBy(ctx context.Context, obj *_model.User) (string, error) {
	panic(fmt.Errorf("not implemented: CreatedBy - createdBy"))
}

// ModifiedBy is the resolver for the modifiedBy field.
func (r *userResolver) ModifiedBy(ctx context.Context, obj *_model.User) (*string, error) {
	panic(fmt.Errorf("not implemented: ModifiedBy - modifiedBy"))
}

// User returns _generated.UserResolver implementation.
func (r *Resolver) User() _generated.UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }
